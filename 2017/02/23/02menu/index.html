<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Android中Menu的种类和使用 | Little Piggy</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="Android">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Android中Menu的种类和使用 | Little Piggy">
    <meta name="twitter:description" content="Android">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Android中Menu的种类和使用 | Little Piggy">
    <meta property="og:description" content="Android">

    
    <meta name="author" content="Jerry">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Little Piggy" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2017/02/23/02menu/"/>

    
      
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Little Piggy 的主页"><img src="/images/avatar.jpg" width="80" alt="Little Piggy logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Little Piggy">Little Piggy</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">Android</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
              <li class="navigation__item"><a href="/favourite">黄金屋</a></li>
            
              <li class="navigation__item"><a href="/favourite/time.html">时光机</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/monniya" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/onlymonniya" title="上Twitter找我" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2017-02-23T03:30:04.073Z" class="post-list__meta--date date">2017-02-22</time> &#8226; <span class="post-meta__tags tags">于&nbsp; </span>
      <span class="page-pv">
      &nbsp;阅读&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Android中Menu的种类和使用</h1>
  </header>

  <section class="post">
    <p>Android中Menu分三种：</p>
<ol>
<li>高版本系统中ActionBar右边的菜单或者按菜单键(如果有的话)弹出的菜单，也是最常见的菜单-Options Menu</li>
<li>长按个别View弹出的Context Menu-Context Menu</li>
<li>屏幕上方弹出的Contextual Action Bar的Menu-Contextual Action Menu</li>
</ol>
<h2 id="Options-Menu"><a href="#Options-Menu" class="headerlink" title="Options Menu"></a>Options Menu</h2><p>效果如下：</p>
<p><img src="http://i.imgur.com/vbQWUbc.png" alt=""></p>
<h3 id="创建Options-Menu"><a href="#创建Options-Menu" class="headerlink" title="创建Options Menu"></a>创建Options Menu</h3><p>1、重写Activity的onCreateOptionsMenu()方法：</p>
<pre><code>override fun onCreateOptionsMenu(menu: Menu?): Boolean {
    logd(&quot;override fun onCreateOptionsMenu(menu: Menu?): Boolean&quot;)
    //使用MenuInflater加载相应的xml文件到menu中
    menuInflater.inflate(R.menu.menu_main, menu)
    return super.onCreateOptionsMenu(menu)//return true
}
</code></pre><p>该方法只会执行一次，就是在Activity打开的时候会回调该方法。如果要在每次弹出菜单的时候对菜单项进行操作，需要重写onPrepareOptionsMenu()方法。</p>
<p>2、重写onPrepareOptionsMenu方法，该方法会在每次打开菜单的时候被调用。</p>
<pre><code>/**
 * Prepare the Screen&apos;s standard options menu to be displayed.  This is
 * called right before the menu is shown, every time it is shown.  You can
 * use this method to efficiently enable/disable items or otherwise
 * dynamically modify the contents.
 *
 * @param menu The options menu as last shown or first initialized by
 *             onCreateOptionsMenu().
 *
 * @return You must return true for the menu to be displayed;
 *         if you return false it will not be shown.
 */
override fun onPrepareOptionsMenu(menu: Menu?): Boolean {
    logd(&quot;override fun onPrepareOptionsMenu(menu: Menu?): Boolean&quot;)
    val visible = menu?.getItem(0)?.isVisible
    if (visible != null) {
        //如果第一项MenuItem可见，将它设置为不可见；如果不可见，设置为可见
        menu?.getItem(0)?.isVisible = visible.not()
    }
    return super.onPrepareOptionsMenu(menu)//return true
}
</code></pre><h3 id="处理菜单项的点击事件"><a href="#处理菜单项的点击事件" class="headerlink" title="处理菜单项的点击事件"></a>处理菜单项的点击事件</h3><p>重写onOptionsItemSelected()方法。</p>
<pre><code>override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    logd(&quot;override fun onOptionsItemSelected(item: MenuItem?): Boolean&quot;)
    when (item?.itemId) {
        R.id.menuMainSettings -&gt; {
            toast(&quot;Settings&quot;)
            return true
        }
        R.id.menuMainEdit -&gt; {
            toast(&quot;Edit&quot;)
            return true
        }
        R.id.menuMainShare -&gt; {
            toast(&quot;Share&quot;)
            return true
        }
        R.id.menuMainTakePhoto -&gt; {
            toast(&quot;TakePhoto&quot;)
            return true
        }
        else -&gt; {
            //默认的返回super.onOptionsItemSelected(item)
            return super.onOptionsItemSelected(item)
        }
    }
}
</code></pre><h2 id="Context-Menu"><a href="#Context-Menu" class="headerlink" title="Context Menu"></a>Context Menu</h2><h3 id="Context-Menu原理"><a href="#Context-Menu原理" class="headerlink" title="Context Menu原理"></a>Context Menu原理</h3><p>效果如下：</p>
<p><img src="http://i.imgur.com/56RSQyY.png" alt=""></p>
<p>ContextMenu在<strong>长按</strong>一个View的时候才有可能会弹出来。看源码：</p>
<p>1、事件分发肯定是从dispatchTouchEvent方法开始，在dispatchTouchEvent方法中，如果没有设置onTouchListener监听，那么会直接去调用onTouchEvent方法；如果设置了onTouchListener监听，分两种情况：(1)监听事件的onTouch方法返回true，这种情况就是onTouch方法直接消费掉了该事件，不会调用onTouchEvent方法；(2)监听事件的onTouch方法返回false，这种情况是onTouch方法不消费该事件，就会去调用onTouchEvent方法。</p>
<pre><code>boolean result = false;
...
ListenerInfo li = mListenerInfo;
if (li != null &amp;&amp; li.mOnTouchListener != null
        &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
        &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
    result = true;
}

if (!result &amp;&amp; onTouchEvent(event)) {
    result = true;
}
</code></pre><p>2、onTouchEvent方法里面，先判断该View是否可用，如果View不可用，直接return：</p>
<pre><code>// A disabled view that is clickable still consumes the touch
// events, it just doesn&apos;t respond to them.
return (((viewFlags &amp; CLICKABLE) == CLICKABLE
        || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
        || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
</code></pre><p>如果View可用，就判断这个MotionEvent的action是MotionEvent.ACTION_UP、MotionEvent.ACTION_MOVE还是MotionEvent.ACTION_DOWN，一个MotionEvent肯定是先从MotionEvent.ACTION_DOWN开始，所以我们先看看MotionEvent.ACTION_DOWN的情况：</p>
<pre><code>case MotionEvent.ACTION_DOWN:
    // LongClick消费事件的标识，初始为false，如果LongClick消费了该事件，该值变为true；记住该变量，后面会用到
    mHasPerformedLongPress = false;

    if (performButtonActionOnTouchDown(event)) {
        break;
    }

    // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.
    boolean isInScrollingContainer = isInScrollingContainer();

    // For views inside a scrolling container, delay the pressed feedback for
    // a short period in case this is a scroll.
    if (isInScrollingContainer) {
        mPrivateFlags |= PFLAG_PREPRESSED;
        if (mPendingCheckForTap == null) {
            mPendingCheckForTap = new CheckForTap();
        }
        mPendingCheckForTap.x = event.getX();
        mPendingCheckForTap.y = event.getY();
        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
    } else {
        // Not inside a scrolling container, so show the feedback right away
        setPressed(true, x, y);
        // 如果该View不可滚动，会调用checkForLongClick方法
        checkForLongClick(0, x, y);
    }
    break;
</code></pre><p>可以看到，在DOWN事件里面会进行一次判断，判断该View是否可以滚动的，如果不可以滚动，会直接去调用checkForLongClick方法：</p>
<pre><code>private void checkForLongClick(int delayOffset, float x, float y) {
    // 如果该View支持LONG_CLICKABLE的话
    if ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) {
        mHasPerformedLongPress = false;

        if (mPendingCheckForLongPress == null) {
            // CheckForLongPress实现了Runnable接口
            mPendingCheckForLongPress = new CheckForLongPress();
        }
        mPendingCheckForLongPress.setAnchor(x, y);
        mPendingCheckForLongPress.rememberWindowAttachCount();
        // 将CheckForLongPress的实现实例post到消息队列里面，等待Handler处理
        postDelayed(mPendingCheckForLongPress,
                ViewConfiguration.getLongPressTimeout() - delayOffset);
    }
}
</code></pre><p>可以看到checkForLongClick方法开启了一个Runnable并post到消息队列里面了。Handler处理它的时候肯定会调用它的run()方法：</p>
<pre><code>private final class CheckForLongPress implements Runnable {

    @Override
    public void run() {
        if (isPressed() &amp;&amp; (mParent != null)
                &amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) {
            if (performLongClick(mX, mY)) {
                mHasPerformedLongPress = true;
            }
        }
    }
</code></pre><p>在run方法中，调用performLongClick方法：</p>
<p>最终会调用performLongClickInternal方法：</p>
<pre><code>/**
 * Calls this view&apos;s OnLongClickListener, if it is defined. Invokes the
 * context menu if the OnLongClickListener did not consume the event,
 * optionally anchoring it to an (x,y) coordinate.
 */
private boolean performLongClickInternal(float x, float y) {
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);

    boolean handled = false;
    final ListenerInfo li = mListenerInfo;
    if (li != null &amp;&amp; li.mOnLongClickListener != null) {
        handled = li.mOnLongClickListener.onLongClick(View.this);
    }
    if (!handled) {
        final boolean isAnchored = !Float.isNaN(x) &amp;&amp; !Float.isNaN(y);
        handled = isAnchored ? showContextMenu(x, y) : showContextMenu();
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    }
    return handled;
}
</code></pre><p>该方法中，先声明一个变量：handled = false；然后去调用onLongClickListener的onLongClick方法(如果设置了onLongClickListener的话，如果没设置就直接走下一个if判断了)，如果onLongClick方法返回的是true，该方法就返回true了；该方法返回true，mHasPerformedLongPress变量的值就会是true，待会该事件走到MotionEvent.ACTION_UP的时候就不会去调用onClick方法了，待会看onTouchEvent中的MotionEvent.ACTION_UP分支；如果onLongClick返回false，就会进入下一个if语句，就会调用showContextMenu(x,y)或者showContextMenu()方法，这两个方法就是弹出ContextMenu的，如果弹出了，handled的值就变成true了，结果也是mHasPerformedLongPress变量的值变为true，同样不走onClick方法。</p>
<p>其实到这里就得出结论了：ContextMenu需要长按View才能弹出，并且在onLongClick方法执行之后(如果设置了OnLongClickListener的话)，如果onLongClick消费了事件(即返回true)，就不会弹出ContextMenu。</p>
<p>再看一下onTouchEvent的MotionEvent.ACTION_UP分支：</p>
<pre><code>case MotionEvent.ACTION_UP:
    boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {
        // take focus if we don&apos;t have it already and we should in
        // touch mode.
        boolean focusTaken = false;
        if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {
            focusTaken = requestFocus();
        }

        if (prepressed) {
            // The button is being released before we actually
            // showed it as pressed.  Make it show the pressed
            // state now (before scheduling the click) to ensure
            // the user sees it.
            setPressed(true, x, y);
       }
        //▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
        if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
            // This is a tap, so remove the longpress check
            removeLongPressCallback();

            // Only perform take click actions if we were in the pressed state
            if (!focusTaken) {
                // Use a Runnable and post this rather than calling
                // performClick directly. This lets other visual state
                // of the view update before click actions start.
                if (mPerformClick == null) {
                    mPerformClick = new PerformClick();
                }
                if (!post(mPerformClick)) {
                    performClick();
                }
            }
        }
        //▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

        if (mUnsetPressedState == null) {
            mUnsetPressedState = new UnsetPressedState();
        }

        if (prepressed) {
            postDelayed(mUnsetPressedState,
                    ViewConfiguration.getPressedStateDuration());
        } else if (!post(mUnsetPressedState)) {
            // If the post failed, unpress right now
            mUnsetPressedState.run();
        }

        removeTapCallback();
    }
    mIgnoreNextUpEvent = false;
    break;
</code></pre><p>这里只关注▼和▲之间的代码：</p>
<p>如果mHasPerformedLongPress的值为true，即onLongClick或者ContextMenu消费了本次事件，该if语句就不会执行，也不会执行下面的performClick()方法(onClick方法在这里回调)。</p>
<p>可见OnClickListener的onClick方法经历了多么艰难的一大段历程之后才能被执行到啊：(不考虑View不可用的情况)</p>
<p>1、onTouch不消费该事件–保证执行onTouchEvent方法</p>
<p>2、onLongClick不消费该事件–保证mHasPerformedLongPress的值不为true</p>
<p>3、ContextMenu不消费该事件–保证mHasPerformedLongPress的值不为true</p>
<p>onClick事件的地位很低啊，还没考虑事件cancel掉的情况。</p>
<h3 id="Context-Menu实现"><a href="#Context-Menu实现" class="headerlink" title="Context Menu实现"></a>Context Menu实现</h3><p>巴拉巴拉一大堆，还没说ContextMenu怎么实现，其实很简单，步骤如下：</p>
<p>1、调用Activity的方法registerForContextMenu(View)并传递过去要注册的View，例如：registerForContextMenu(textview)或registerForContextMenu(listview);如果注册的是AbsListView的子类，那么长按AbsListView的每个条目都会弹出ContextMenu</p>
<pre><code>registerForContextMenu(textview)//就一行代码，是不是很简单
//其实内部实现就是view.setOnCreateContextMenuListener(this);set了一个OnCreatContextMenuListener
</code></pre><p>2、重写Activity的onCreateContextMenu(初始化menu)和onContextItemSelected(处理menu item的点击事件)</p>
<pre><code>/**
 * Called when a context menu for the {@code view} is about to be shown.
 * Unlike {@link #onCreateOptionsMenu(Menu)}, this will be called every
 * time the context menu is about to be shown and should be populated for
 * the view (or item inside the view for {@link AdapterView} subclasses,
 * this can be found in the {@code menuInfo})).
 *
 */
override fun onCreateContextMenu(menu: ContextMenu?, v: View?, menuInfo: ContextMenu.ContextMenuInfo?) {
    super.onCreateContextMenu(menu, v, menuInfo)
    logd(&quot;override fun onCreateContextMenu(menu: ContextMenu?, v: View?, menuInfo: ContextMenu.ContextMenuInfo?)\nview:$v&quot;)
    // 如果v是AbsListView的子类，menuInfo不为空；否则为空
    logd(&quot;menuInfo: $menuInfo&quot;)
    // 如果一个Activity里面对不同的View设置了不同的ContextMenu，可根据View进行判断，然后加载不同的menu
    if (v == listview)
        menuInflater.inflate(R.menu.menu_main, menu)
    else if (v == textview)
        menuInflater.inflate(R.menu.menu_textview_action, menu)
}

override fun onContextItemSelected(item: MenuItem?): Boolean {
    logd(&quot;override fun onContextItemSelected(item: MenuItem?): Boolean&quot;)
    // 如果MenuItem的menuInfo不为空，说明是view是AbsListView的子类
    // 可以通过menuInfo获取到点击的条目在AbsListView中的位置position,从而进行相应的操作
    if (null != item?.menuInfo) {
        val menuInfo = item?.menuInfo as AdapterView.AdapterContextMenuInfo
        when (item?.itemId) {
            R.id.menuMainEdit -&gt; {
                //根据menuInfo获取到position，并移除position位置的条目，然后notify，实现长按删除等功能
                datas.removeAt(menuInfo.position)
                listViewAdapter.notifyDataSetChanged()
                return true
            }
            else -&gt; {
                logd(&quot;其他操作&quot;)
            }
        }
    } else {
        logd(&quot;TextView的菜单操作&quot;)
    }
    return super.onContextItemSelected(item)
}
</code></pre><p>上面的代码看注释。</p>
<h2 id="Contextual-Action-Menu"><a href="#Contextual-Action-Menu" class="headerlink" title="Contextual Action Menu"></a>Contextual Action Menu</h2><p>效果如下：</p>
<p><img src="http://i.imgur.com/wuSW8Xi.png" alt=""></p>
<p>就是在屏幕上方弹出一个类似于ActionBar的悬浮框，里面有菜单条目，还可以设置Action的Title。</p>
<p>实现方式有两种：</p>
<h3 id="第一种：实现单个View的Contextual-Action-Menu"><a href="#第一种：实现单个View的Contextual-Action-Menu" class="headerlink" title="第一种：实现单个View的Contextual Action Menu"></a>第一种：实现单个View的Contextual Action Menu</h3><p>1、实现ActionMode.CallBack接口：</p>
<pre><code>private val callback = object : Callback {
    // Called each time the action mode is shown. Always called after onCreateActionMode, but
    // may be called multiple times if the mode is invalidated.
    override fun onPrepareActionMode(mode: ActionMode?, menu: Menu?): Boolean {
        logd(&quot;TextView的Contextual Action Bar要打开了，可以做一些相关的判断，比如：\nremove一些menuItem\n添加一些menuItem 等。&quot;)
        return true
    }

    // Called when the user selects a contextual menu item
    override fun onActionItemClicked(mode: ActionMode?, item: MenuItem?): Boolean {
        when (item?.itemId) {
            R.id.menuActionCopy -&gt; {
                toast(&quot;复制内容&quot;)
                // 设置mode的标题
                mode?.title = &quot;复制内容&quot;
                return true
            }
            R.id.menuActionCut -&gt; {
                toast(&quot;剪切内容&quot;)
                mode?.title = &quot;剪切内容&quot;
                return true
            }
            R.id.menuActionCancel -&gt; {
                toast(&quot;取消&quot;)
                // 关闭mode
                mode?.finish()
                return true
            }
            else -&gt; return false
        }
    }

    // Called when the action mode is created; startActionMode() was called
    override fun onCreateActionMode(mode: ActionMode?, menu: Menu?): Boolean {
        //同样是利用MenuInflater加载相应的menu的xml资源
        menuInflater.inflate(R.menu.menu_textview_action, menu)
        logd(&quot;TextView 的Contextual Action Bar要create了，需要做初始化的操作&quot;)
        return true
    }

    // Called when the user exits the action mode
    override fun onDestroyActionMode(mode: ActionMode?) {
        logd(&quot;TextView的Contextual Action Bar销毁了。。。。。&quot;)
        startActionMode = null
    }

}
</code></pre><p>so easy，照着做就行了。</p>
<p>2、在适当的时候调用Activity的startActionMode()方法开启ContextualActionBar(这里选择在textview的点击事件中开启)：</p>
<pre><code>textview.setOnClickListener({
    if (null == startActionMode)
    // Start the CAB using the ActionMode.Callback defined above
        startActionMode = startActionMode(callback)
})
</code></pre><p>startActionMode(CallBack)方法返回一个ActionMode对象，也就是正在开启的ActionMode，可以先判断它是否为null，如果是null的时候才开启，可以防止重复开启，消耗内存。在CallBack的onDestroyActionMode方法中将该ActionMode对象置为null。</p>
<p>可以用Theme修改ContextualActionBar的样式：</p>
<pre><code>&lt;!--修改ContextualActionBar的背景颜色--&gt;
&lt;item name=&quot;actionModeBackground&quot;&gt;@color/colorAccent&lt;/item&gt;
&lt;!--修改ContextualActionBar左侧的关闭图标--&gt;
&lt;item name=&quot;actionModeCloseDrawable&quot;&gt;@mipmap/right&lt;/item&gt;
</code></pre><p>还可以修改其他系统内置的属性：</p>
<p><img src="http://i.imgur.com/Md7R0GP.png" alt=""></p>
<h3 id="第二种，实现AbsListView的多选功能"><a href="#第二种，实现AbsListView的多选功能" class="headerlink" title="第二种，实现AbsListView的多选功能"></a>第二种，实现AbsListView的多选功能</h3>
  </section>

</article>
<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/03/01/03ArrayList源码小细节/" title=""></a></h2>
                <p class="excerpt">
                
                ArrayList源码中有一个构造函数代码如下：
/**
 * Constructs a list containing the elements of the specified
 * collection, in the order they are returned by the collec
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-03-01T02:06:27.355Z" class="post-list__meta--date date">2017-02-28</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;</span><a class="btn-border-small" href="/2017/03/01/03ArrayList源码小细节/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/02/17/01requestWindowFeature(Window.FEATURE_NO_TITLE)无效/" title="requestWindowFeature(Window.FEATURE_NO_TITLE)无效">requestWindowFeature(Window.FEATURE_NO_TITLE)无效</a></h2>
                <p class="excerpt">
                
                当你的activity继承的是Activity时，requestWindowFeature(Window.FEATURE_NO_TITLE)是可以隐藏标题栏的；但是，当你的activity继承的是AppCompatActivity时，requestWindowFeature(Window.FEATU
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-02-17T01:52:50.963Z" class="post-list__meta--date date">2017-02-16</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;</span><a class="btn-border-small" href="/2017/02/17/01requestWindowFeature(Window.FEATURE_NO_TITLE)无效/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

            
            <footer class="footer">
    <span class="footer__copyright">
        本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2017 - 本站由 <a href="/">@Monniya</a> 创建,
        使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">hexo-theme-new-vno</a> 主题,
        修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
    </span>
</footer>
        </div>
    </div>

    

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
    
    </script>
    
</body>
</html>
